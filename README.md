# Tech Startup Maturity Levels
A software company is formed to mainly build solutions that a target market has demand for. For a tech company to be 
generally successful at what they do, they need to build their software solution in a way that: 

* It continuously delivers value to the end users with best user experience possible.
* It has high quality and it's well-engineered.
* It's scalable, maintainable, and future friendly as much as possible.
* It continuously minimizes time and financial costs during software delivery to increase profitability.
* It continuously drives innovation to be relevant in the ever-changing tech scene.

In reality, tech companies are in the constant battle of time, resources, and deliverables. The product management
team along with tech leadership decides what needs to be done to achieve aforementioned goals. Companies at different
levels of maturity need to be equipped with right technologies and processes to be considered high performing. 

Here is the checklist for every level of maturity of any tech company. The higher level a tech company is on this scale,
the more it's considered a high performing tech organization.

## Level 1
* Structured goal setting is in place: Using a systematic way of setting goals that drives what is built by developers.
 This brings alignment to all functions of an organization and helps everyone have focus and ensure individual 
 contributors are working on the right thing. Let's face it, building and shipping software is very expensive! therefore,
 building the wrong products or features can really hurt a tech company. [OKRs](https://www.goodreads.com/book/show/39286958-measure-what-matters) 
 are a very handy tool for structured goal setting.
* Use a software development methodology that works for your team.
* Extreme ownership in the engineering team: once developers are code complete, they are not done! They are trained to 
have this mindset that they are done once what they are working on is in production creating value for end-users.
* Continuous negotiation with the product team: continuous negotiation with the product team: There is a constant line 
of communication open between engineers and product managers to bring down the feature scope/complexity while not 
drastically minimize the value delivered to the user. The result of this practice is to save time and development costs
while still delivering great customer experience.  
* Using an issue & project tracking software system: Platforms such as Jira enable you to implement the software 
development methodology you are using and ensure any engineering work is being tracked through the entire development
lifecycle.    
* Using version control systems, proper branching and code merging model that works for your team resulting in fast code
integration.
* Using an effective communication mechanism such as Slack.
* Developers can reproduce bugs and test everything in their development environments
## Level 2
* Everything mentioned in level 1 is practiced
* Prioritization model: you know what to work on
* Product team always ensures there is high priority work for engineers to do
* Engineers knowing the big picture
* Processes are defined in a way that people are not blocked on each other too often. 
be very attentive to the word "blocked" and resolve it immediately
* production bugs triage: low priority bugs vs high priority ones
* Ensure developers are happy and appreciated by having retros
* Get architectural design buy in before implementation
* Having a systematic way of communicating what is going to be built long term and short term and communicate internally
 and externally what is being released.  
* environments are isolated
* Logging application output and developers have access to logs in all environments 
## Level 3
* Everything mentioned in level 2 is practiced
* Build out technology radar
* Unify design systems: having style guides
* Educate engineers to be product-oriented rather than purely thinking technical
* Test plan in place and test management in place
* Develop with SEO in mind
* Develop with mobile-first mind set
* CI/CD/Zero downtime deployments
* Start gathering data about users and how they are using your software
## Level 4
* Everything mentioned in level 3 is practiced
* Maximize code reusability strategy
* Documentation of the features systematically
* Constantly asking our self this question: Are we automating anything that can be automated?
* Unit tests(mocking things that need to be mocked), integration tests, end 2 end tests automated
* Have a systematic way to handle escalations and close the loop with support and non-tech stake holders
* Post-mortems when things go wrong
* There is a systematic way of training and onboarding in place for new hires, There is onboarding/offboarding strategy 
and not tying shred documents to people but the org itself
* There is a structure in place for tech guys and a systematic way for people to grow
* common data exposure protocol
* Feature toggle strategy
## Level 5
* Everything mentioned in level 4 is practiced
* Monitoring performance and find what's slowing down on both the front-end and the back-end
* Monitoring service health to be proactive instead of reactive when problems arise
* Having a systematic way to monitor security and develop with security in mind
* People think about cost of service vs ROI and scalability when choosing a technology to use
* Load testing in place
* Design with redundancy in mind
* User activity tracking system
* A/B testing strategy
* Train everyone to be a leader

Feel free to submit PRs if you think there are items missing in this checklist. If you need help implementing any of the
 levels in your organization, you can reach out to me through my website at [www.mehdi.tech](https://www.mehdi.tech)

