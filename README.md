# Tech Startup Maturity Levels
A software company is formed to mainly build solutions that a target market has demand for. For a tech company to be 
generally successful at what they do, they need to build their software solution in a way that: 

* It continuously delivers value to the end users with best user experience possible.
* It has high quality and it's well-engineered.
* It's scalable, maintainable, and future friendly as much as possible.
* It continuously minimizes time and financial costs to increase profitability.
* It continuously drives innovation to be relevant in the ever-changing tech scene.

In reality, tech companies are in the constant battle of time, resources, and deliverables. The product management
team along with tech leadership decides what needs to be done to achieve aforementioned goals. Companies at different
levels of maturity need to be equipped with right technologies and processes to be considered high performing. 

Here is the checklist for every level of maturity of any tech company.
## Level 1
This level is required for every tech company to be functional at the bare level. early stage startups building minimal
viable products and validating their proof of concept fall into this level.
* Using version control systems and proper branching and code merging model
* Using a issue tracking system
* Structured goal setting that drives what is built by developers
* developers can reproduce bugs and test everything in their local environments during development
* Definition of done for a feature: one word. Impact!
## Level 2
* Product team always ensures there is high priority work for engineers to do
* Processes are defined in a way that people are not blocked on each other too often
* Constantly asking our self this question: Are we automating anything that can be automated?
* developers have access to logs in all environments
* environments are isolated
* there is ownership of the feature all the way to production
* unit tests(mocking things that need to be mocked), integration tests, end 2 end tests automated
* production bugs triage: low priority bugs vs high priority ones
* be very attentive to the word "blocked" and resolve it immediately
* documentation of the features systematically
* maximize code reusability strategy
* unify design systems, having style guides
* streamline deployments (Continuous software delivery)
* alignment from exec -> product -> development
* Educate engineers to be product-oriented rather than purely thinking technical
* Develop with SEO in mind
* Ensure developers are happy and appreciated by having retros
* CI/CD/Zero downtime deployments
* Logging application output
* People knowing the big picture
* Prioritization model: you know what to work on
* post-mortems when things go wrong
* common data exposure protocol
* Have a systematic way to handle escalations and close the loop with support and non-tech stake holders
* Test plan in place and test management in place
* Negotiate with the product team constantly
* There is a structure in place for tech guys and a systematic way for people to grow
* There is a systematic way of training and onboarding in place for new hires, There is onboarding/offboarding strategy 
and not tying shred documents to people but the org itself
* Develop with mobile-first mind set
* Get architectural design buy in before implementation
* Having a systematic way of communicating what is going to be built long term and short term and communicate internally
 and externally what is being released.  
## Level 3
* Monitoring performance and find what's slowing down on both the front-end and the back-end
* Monitoring service health to be proactive instead of reactive when problems arise
* Having a systematic way to monitor security and develop with security in mind
* People think about cost of service vs ROI and scalability when choosing a technology to use
* Load testing in place
* Design with redundancy in mind
* User activity tracking system
* Train everyone to be a leader

