# Tech Startup Maturity Levels
A software company is formed to mainly build solutions that a target market has demand for. For a tech company to be 
generally successful at what they do, they need to build their software solution in a way that: 

* It continuously delivers value to the end users with best user experience possible.
* It has high quality and it's well-engineered.
* It's scalable, maintainable, and future friendly as much as possible.
* It continuously minimizes time and financial costs to increase profitability.
* It continuously drives innovation to be relevant in the ever-changing tech scene.

In reality, tech companies are in the constant battle of time, resources, and deliverables. The product management
team along with tech leadership decides what needs to be done to achieve aforementioned goals. Companies at different
levels of maturity need to be equipped with right technologies and processes to be considered high performing. 

Here is the checklist for every level of maturity of any tech company.
## Level 1
This level is required for every tech company to be functional at the bare level. early stage startups building minimal
viable products and validating their proof of concept fall into this level.
* Using version control systems and proper branching and code merging model
* Using a issue tracking system
* Use a well-known software development methodology 
* Structured goal setting that drives what is built by developers: alignment from exec -> product -> development
* developers can reproduce bugs and test everything in their local environments during development
* Definition of done for a feature: one word. Impact! There is ownership of the feature all the way to production
* Negotiate with the product team constantly
## Level 2
* Product team always ensures there is high priority work for engineers to do
* Processes are defined in a way that people are not blocked on each other too often. 
be very attentive to the word "blocked" and resolve it immediately
* Logging application output and developers have access to logs in all environments
* environments are isolated
* production bugs triage: low priority bugs vs high priority ones
* Ensure developers are happy and appreciated by having retros
* Engineers knowing the big picture
* Prioritization model: you know what to work on
* Get architectural design buy in before implementation
* Having a systematic way of communicating what is going to be built long term and short term and communicate internally
 and externally what is being released.  
## Level 3
* CI/CD/Zero downtime deployments
* unify design systems: having style guides
* Develop with SEO in mind
* Develop with mobile-first mind set
* Test plan in place and test management in place
* Educate engineers to be product-oriented rather than purely thinking technical
## Level 4
* maximize code reusability strategy
* documentation of the features systematically
* Constantly asking our self this question: Are we automating anything that can be automated?
* Unit tests(mocking things that need to be mocked), integration tests, end 2 end tests automated
* Have a systematic way to handle escalations and close the loop with support and non-tech stake holders
* post-mortems when things go wrong
* There is a systematic way of training and onboarding in place for new hires, There is onboarding/offboarding strategy 
and not tying shred documents to people but the org itself
* There is a structure in place for tech guys and a systematic way for people to grow
* common data exposure protocol
## Level 5
* Monitoring performance and find what's slowing down on both the front-end and the back-end
* Monitoring service health to be proactive instead of reactive when problems arise
* Having a systematic way to monitor security and develop with security in mind
* People think about cost of service vs ROI and scalability when choosing a technology to use
* Load testing in place
* Design with redundancy in mind
* User activity tracking system
* Train everyone to be a leader

